# 指令集

## 基本指令集

基本指令集占有`0`~`63`的指令编码码位，提供处理器管理指令以及最基本且必需的运算和寄存器、储存器管理指令。

在操作对象上，基本指令集中分为以下几种指令：

* 寄存器指令：绝大多数用到寄存器的指令都属于此类；
* 内存指令：`ldm`和`stm`；
* 转移指令：能直接作用于ip寄存器的指令；
* 系统管理指令：下表中有`*`的为系统管理指令。

一条指令分为两部分：

* 操作码：指令名对应的编码
* 操作数：操作数分为`寄存器操作数`、`立即数操作数`和`内存操作数`；大多数指令都使用寄存器操作数，只在某些必要的指令中使用立即数和内存操作数。

> 指令编号后有`*`的为系统管理指令，只能在内核态调用。
> 空白的指令编号为保留使用

编号|指令格式|编码|指令名|说明
:-:|:-|:-|:-|:-
0       |nop                 |00                                    |空指令         |暂停CPU直到中断产生
1       |add r1, r2, r3      |01 r1[4],r2[4] r3[4],wide[4]          |加法
2       |sub r1, r2, r3      |02 r1[4],r2[4] r3[4],wide[4]          |减法
3       |inc r1              |03 r1[4],wide[4]                      |自增1
4       |dec r1              |04 r2[4],wide[4]                      |自减1
5       |shl r1, r2          |05 r1[4],r2[4] wide[8]                |左位移         |将r2左移r1位
6       |shr r1, r2          |06 r1[4],r2[4] wide[8]                |右位移
7       |rol r1, r2          |07 r1[4],r2[4] wide[8]                |左旋
8       |ror r1, r2          |08 r1[4],r2[4] wide[8]                |右旋
9       |cmp r1, r2          |09 r1[4],r2[4]                        |比较
10      |and r1, r2, r3      |0a r1[4],r2[4] r3[4],wide[4]          |与运算
11      |or r1, r2, r3       |0b r1[4],r2[4] r3[4],wide[4]          |或运算
12      |not r1, r2          |0c r1[4],r2[4]                        |非运算
13      |xor r1, r2, r3      |0d r1[4],r2[4] r3[4],wide[4]          |异或运算
14      |                    |0e                                    |
15      |                    |0f                                    |
15      |                    |10                                    |
15      |                    |11                                    |
15      |                    |12                                    |
15      |                    |13                                    |
20      |jc(w/d/q) imm       |14 16/32/64[4],cond[4] imm[16/32/64]  |指令跳转
21      |cc(w/d/q) imm       |15 16/32/64[4],cond[4] imm[16/32/64]  |函数调用        |返回地址存于x0
22      |r                   |16                                    |从函数返回       |跳回x0所指的地址
23      |loop r, imm         |17 r1[8],imm[32]                      |条件循环        |r为非零时跳转到相对地址imm处
24*     |ir imm              |18 mod[8]                             |从中断返回
25      |sysc                |19                                    |陷入内核态
26*     |sysr                |1a                                    |跳回用户态
27      |                    |1b                                    |
28      |ldi(b/w/d/q) imm, r |1c 8/16/32/64[4],r[4] imm[8/16/32/64] |加载立即数
29      |ldm r1, r2          |1d r1[4],r2[4] wide[8]                |从内存加载       |将r1所指的内存处的数据加载到r2中（r1前可不加*号）
30      |stm r1, r2          |1e r1[4],r2[4] wide[8]                |保存到内存       |将r1的内容保存到r2所指的内存中（r2前可不加*号）
31      |mv r1/\*m1,r2/\*m2  |1f mvflg[8] r1[4],r2[4]               |移动数据        |将r1移动至r2(不建议使用)(需要重新设计)
32*     |in imm/r1,r2        |20 r2[4],mvflg[4] imm[8]/r1[4]        |端口输入        |第一个参数是端口号，第二个是储存输入的寄存器，只输入1字节
33*     |out r1,imm/r2       |21 r1[4],mvflg[4] imm[8]/r2[4]        |端口输出        |第一个是储存输入的寄存器，第二个参数是端口号，只输出寄存器的第一字节
34      |                    |22                                    |
35      |                    |23                                    |
36      |                    |24                                    |
37      |                    |25                                    |
38      |                    |26                                    |
39      |                    |27                                    |
40      |                    |28                                    |
41      |                    |29                                    |
42      |                    |2a                                    |
43      |                    |2b                                    |
44      |                    |2c                                    |
45      |                    |2d                                    |
46      |                    |2e                                    |
47      |                    |2f                                    |
48*     |ei                  |30                                    |使能中断
49*     |di                  |31                                    |关闭中断
50*     |ep                  |32                                    |使能分页
51*     |dp                  |33                                    |关闭分页
52*     |livt r              |34 r[8]                               |加载中断向量表
53*     |lkpt r              |35 r[8]                               |加载内核态页表
54*     |lupt r              |36 r[8]                               |加载用户态页表
55*     |lscp r              |37 r[8]                               |加载系统调用指针
55      |lipdump r           |38 r[8]                               |将ipdump加载到寄存器中
57      |lflagdump r         |39 r[8]                               |将flgdump加载到寄存器中
58      |sipdump r           |3a r[8]                               |将寄存器的值写入ipdump
59      |sflagdump r         |3a r[8]                               |将寄存器的值写入flgdump
60      |cpuid               |3c                                    |获取处理器信息和一些硬件信息|详见[cpuid](#cpuid)一节
61*     |initext r           |3d r[8]                               |初始化扩展指令集    |r为指令集代码
62*     |destext             |3e                                    |销毁扩展指令集
63      |                    |3f                                    |

* 条件指令名:

[jc]|[cc]
:-|:-
j       |c
je      |ce
jb      |cb
js      |cs
jne     |cne
jnb     |cnb
jns     |cns
jh      |ch
jl      |cl
jnh     |cnh
jnl     |cnl
jo      |co
jz      |cz

* 条件码:

[cond]|说明|注
:-:|:-|:-
0       |non        |
1       |equal      |
2       |bigger     |将两数作为无符号整数比较
3       |smaller    |将两数作为无符号整数比较
4       |n-equal    |
5       |n-bigger   |
6       |n-smaller  |
7       |higher     |将两数作为有符号整数比较
8       |lower      |将两数作为有符号整数比较
9       |n-higher   |
a       |n-lower    |
b       |overflow   |
c       |zero       |
d       |signed     |

* 中断返回模式码

[mod]|说明
:-:|:-
0       |panic, 复位CPU
1       |retry, 重新执行指令

* 移动指令标志位

[mvflg]|说明
:-:|:-
0       |r1,r2
1       |r,m
2       |m,r
3       |m1,m2

### cpuid

cpuid指令可获得处理器的硬件信息。（或者一些特殊功能）

> x1中的`*`代表可以是任意值。

参数寄存器|x0   |x1    |返回结果
:-:|:-|:-|:-
|     |0     |*     |EOM，最多32字节，存在x1、x2、x3、x4中
|     |1     |*     |共有多少核心，存在x0中
|     |2     |*     |返回此核心的id，存在x0中
|     |3     |*     |在运行vrisc的终端中输出x1指向的字符串
|     |4     |*     |软件模拟(1)/物理硬件(0)

## 寄存器

* 通用寄存器：16个，`x0`~`x15`
* 指令指针寄存器：与通常不同，由于指令集实现为纯软件，指向目前要执行的指令比指向下一条指令更加合理。
* 标志位寄存器：标志系统状态
  * ^0 零标志
  * ^1 相等标志
  * ^2 符号标志
  * ^3 溢出标志
  * ^4 绝对大于标志
  * ^5 绝对小于标志
  * ^6 相对大于标志
  * ^7 相对小于标志
  * ^8 中断使能标志
  * ^9 分页使能标志
  * ^10 特权级标志(0: 内核态)
* 中断向量表寄存器：指向中断向量表（中断向量表有关详见[中断机制](interrupt.md)）
* 内核态/用户态页表指针寄存器：分页机制相关寄存器（见[分页机制](#分页机制)）
* 系统调用指针寄存器
* 中断信息寄存器：发生中断时中断信息存在此寄存器
* ipdump寄存器：在发生跳转或中断时，跳转前的ip将被转存至此
* flagdump寄存器：在发生中断时，跳转前的ip将被转存至此

## 分页机制

分页机制由`标志位寄存器`的第7位开启。

分为`用户态`和`内核态`两组页表。

顶级页目录由`内核态/用户态页表指针寄存器`储存。

通过分页机制，可以使用`虚拟地址空间`来访问内存。

一个普通物理页的大小为16KB。

### 虚拟地址

没有开启分页时，机器使用物理地址访问内存。

开启分页时，使用虚拟地址空间访问内存。

虚拟地址为64位地址，包含整个虚拟地址空间；虚拟地址的最高位为用户标志位，最高位置位则表示此地址为用户态地址，否则表示内核态地址。

虚拟地址各位段的含义如下：

位|项目
:-|:-:
63      |用户态标志
62~54   |保留
53~44   |四级页表项
43~34   |三级页表项
33~24   |二级页表项
23~14   |一级页表项
13~0    |页内偏移

### 页表和页表项

一个页表项8字节，一个页表最多1024个页表项；

页表的起始地址只能是16K的整数倍；

页表项为一个物理地址，指向低一级的页表起始地址，一级页表项指向物理页起始地址；

页表项数少于1024个时，需要在最后一项后再填充一个64位整数0，表示页表结束。

由于页表项的最低14位一定是0，所以在最低14位中设置了一些标志位，表明它所指的页表或物理页的相关信息，如下：

位|项目|说明
:-|:-:|:-
13~2  |保留使用   |
1     |大页标志   |置位说明此高级页表指向一个物理页，而不是下一级页表。一级页表项的此位无效。
0     |有效标志   |当此页表项指向一个物理页时，复位说明此页不在内存中。

### 大页

大页是高级页表项直接指向的物理页。

当页表项的`大页标志`置位时，高级页表项储存的值应为一个物理页的起始地址。

大页的大小：16M、16G、16T；只要你的内存足够大，就可以分配，机器不会限制。

## 系统调用

操作系统应为系统调用提供一个入口函数，系统调用号可随意设置，系统调用过程中不对参数传递和堆栈操作做出任何要求。

## 扩展指令集

vrisc通过扩展指令集来提供如`基本数学运算扩展`、`单指令多数据扩展`等额外功能。

扩展指令集需要用`initext`与`destext`指令对进行加载和卸载操作。

### 基本数学运算扩展(bae)

### 高级向量扩展(ave)

### 单指令多数据扩展(simde)
